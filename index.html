<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Portfolio</title>
    <style>
        :root {
            --bg: #0a0a0a;
            --text: #f5f5f5;
            --accent: #e8e8e8;
            --hotspot: rgba(255, 255, 255, 0.9);
            --hotspot-hover: rgba(255, 255, 255, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Helvetica Neue', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            overflow: hidden;
            cursor: default;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        canvas {
            display: block;
            outline: none;
        }

        .hotspot {
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--hotspot);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 10;
            pointer-events: auto;
        }

        .hotspot::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 32px;
            height: 32px;
            border: 1px solid var(--hotspot);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        .hotspot:hover {
            background: var(--hotspot-hover);
            transform: translate(-50%, -50%) scale(1.2);
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
            50% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(1.8);
            }
        }

        .tooltip {
            position: absolute;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0;
            border-radius: 2px;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
            width: 280px;
            overflow: hidden;
        }

        .tooltip.active {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .tooltip-image {
            width: 100%;
            height: 160px;
            object-fit: cover;
            display: block;
        }

        .tooltip-content {
            padding: 20px;
        }

        .tooltip-title {
            font-size: 16px;
            font-weight: 400;
            letter-spacing: -0.02em;
            margin-bottom: 8px;
            color: var(--text);
        }

        .tooltip-description {
            font-size: 13px;
            line-height: 1.5;
            color: rgba(245, 245, 245, 0.6);
            margin-bottom: 16px;
        }

        .tooltip-button {
            display: inline-block;
            padding: 8px 16px;
            background: var(--accent);
            color: var(--bg);
            text-decoration: none;
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            border-radius: 1px;
            transition: all 0.2s ease;
            border: none;
            cursor: pointer;
        }

        .tooltip-button:hover {
            background: var(--text);
            transform: translateY(-1px);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(245, 245, 245, 0.5);
        }

        .instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            letter-spacing: 0.05em;
            color: rgba(245, 245, 245, 0.3);
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div class="loading">Lädt...</div>
        <div class="instructions">Klicken und ziehen zum Drehen · Scrollen zum Zoomen</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 3);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enableZoom = true;
        controls.enablePan = false;
        controls.minDistance = 1.5;
        controls.maxDistance = 5;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const keyLight = new THREE.DirectionalLight(0xffffff, 1.2);
        keyLight.position.set(2, 2, 2);
        scene.add(keyLight);

        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-2, 0, -1);
        scene.add(fillLight);

        const rimLight = new THREE.DirectionalLight(0xffffff, 0.8);
        rimLight.position.set(0, 2, -2);
        scene.add(rimLight);

        // Hotspot data - 7 random positions on a head
        const hotspots = [
            {
                position: { x: 0, y: 0.8, z: 0.5 }, // Forehead - adjusted
                title: 'Projekt Alpha',
                description: 'Innovative UI/UX Design für digitale Produkte',
                image: 'https://images.unsplash.com/photo-1558655146-364adaf1fcc9?w=400&h=300&fit=crop',
                link: '#projekt-alpha',
                texture: {
                    image: 'https://images.unsplash.com/photo-1557672172-298e090bd0f1?w=1024&h=1024&fit=crop', // Abstract red texture
                    roughness: 0.3,
                    metalness: 0.5
                }
            },
            {
                position: { x: 0.4, y: 0.5, z: 0.6 }, // Right eye area - adjusted
                title: 'Brand Identity',
                description: 'Komplettes Branding für moderne Startups',
                image: 'https://images.unsplash.com/photo-1634942537034-2531766767d1?w=400&h=300&fit=crop',
                link: '#brand-identity',
                texture: {
                    image: 'https://images.unsplash.com/photo-1567095761054-7a02e69e5c43?w=1024&h=1024&fit=crop', // Abstract teal texture
                    roughness: 0.6,
                    metalness: 0.2
                }
            },
            {
                position: { x: -0.4, y: 0.5, z: 0.6 }, // Left eye area - adjusted
                title: 'Motion Design',
                description: 'Animierte Grafiken und Explainer Videos',
                image: 'https://images.unsplash.com/photo-1551434678-e076c223a692?w=400&h=300&fit=crop',
                link: '#motion-design',
                texture: {
                    image: 'https://images.unsplash.com/photo-1553356084-58ef4a67b2a7?w=1024&h=1024&fit=crop', // Abstract gold texture
                    roughness: 0.4,
                    metalness: 0.7
                }
            },
            {
                position: { x: 0, y: 0.2, z: 0.7 }, // Nose - adjusted
                title: 'Web Development',
                description: 'Responsive Websites mit modernsten Technologien',
                image: 'https://images.unsplash.com/photo-1547658719-da2b51169166?w=400&h=300&fit=crop',
                link: '#web-development',
                texture: {
                    image: 'https://images.unsplash.com/photo-1579546929518-9e396f3cc809?w=1024&h=1024&fit=crop', // Abstract purple texture
                    roughness: 0.5,
                    metalness: 0.3
                }
            },
            {
                position: { x: 0.5, y: 0, z: 0.4 }, // Right cheek - adjusted
                title: '3D Visualisierung',
                description: 'Realistische 3D Renderings und Animationen',
                image: 'https://images.unsplash.com/photo-1618005182384-a83a8bd57fbe?w=400&h=300&fit=crop',
                link: '#3d-visualisierung',
                texture: {
                    image: 'https://images.unsplash.com/photo-1557672199-6903afd4d16f?w=1024&h=1024&fit=crop', // Abstract cyan texture
                    roughness: 0.2,
                    metalness: 0.8
                }
            },
            {
                position: { x: -0.5, y: 0, z: 0.4 }, // Left cheek - adjusted
                title: 'Photography',
                description: 'Professionelle Produktfotografie und Retusche',
                image: 'https://images.unsplash.com/photo-1542038784456-1ea8e935640e?w=400&h=300&fit=crop',
                link: '#photography',
                texture: {
                    image: 'https://images.unsplash.com/photo-1550859492-d5da9d8e45f3?w=1024&h=1024&fit=crop', // Abstract pink texture
                    roughness: 0.7,
                    metalness: 0.1
                }
            },
            {
                position: { x: 0, y: -0.3, z: 0.5 }, // Chin - adjusted
                title: 'Consulting',
                description: 'Strategieberatung für digitale Transformation',
                image: 'https://images.unsplash.com/photo-1553877522-43269d4ea984?w=400&h=300&fit=crop',
                link: '#consulting',
                texture: {
                    image: 'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=1024&h=1024&fit=crop', // Abstract blue texture
                    roughness: 0.5,
                    metalness: 0.4
                }
            }
        ];

        // Create hotspot elements
        const hotspotElements = [];
        let activeTooltip = null;
        let model = null;
        let originalMaterial = null;
        let currentMaterial = null;
        let targetTexture = null;
        let targetRoughness = null;
        let targetMetalness = null;
        let isTransitioning = false;
        const textureLoader = new THREE.TextureLoader();
        const loadedTextures = new Map();

        // Preload all textures
        hotspots.forEach((hotspot, index) => {
            textureLoader.load(hotspot.texture.image, (texture) => {
                texture.colorSpace = THREE.SRGBColorSpace;
                loadedTextures.set(index, texture);
            });
        });

        // Material transition function with texture
        function transitionMaterial(textureIndex, newRoughness, newMetalness) {
            if (loadedTextures.has(textureIndex) && currentMaterial) {
                targetTexture = loadedTextures.get(textureIndex);
                targetRoughness = newRoughness;
                targetMetalness = newMetalness;
                isTransitioning = true;
                
                // Apply texture immediately for instant feedback
                currentMaterial.map = targetTexture;
                currentMaterial.roughness = newRoughness;
                currentMaterial.metalness = newMetalness;
                currentMaterial.needsUpdate = true;
            }
        }

        hotspots.forEach((hotspot, index) => {
            const dot = document.createElement('div');
            dot.className = 'hotspot';
            dot.dataset.index = index;
            document.getElementById('canvas-container').appendChild(dot);
            hotspotElements.push(dot);

            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'tooltip';
            tooltip.innerHTML = `
                <img class="tooltip-image" src="${hotspot.image}" alt="${hotspot.title}">
                <div class="tooltip-content">
                    <div class="tooltip-title">${hotspot.title}</div>
                    <div class="tooltip-description">${hotspot.description}</div>
                    <a href="${hotspot.link}" class="tooltip-button">Mehr erfahren</a>
                </div>
            `;
            document.getElementById('canvas-container').appendChild(tooltip);

            dot.addEventListener('click', (e) => {
                e.stopPropagation();
                
                // Change model texture
                if (model && currentMaterial) {
                    const hotspotData = hotspots[index];
                    transitionMaterial(
                        index,
                        hotspotData.texture.roughness,
                        hotspotData.texture.metalness
                    );
                }
                
                // Close previous tooltip
                if (activeTooltip && activeTooltip !== tooltip) {
                    activeTooltip.classList.remove('active');
                }

                // Toggle current tooltip
                const isActive = tooltip.classList.contains('active');
                tooltip.classList.toggle('active');
                activeTooltip = isActive ? null : tooltip;

                // Position tooltip
                const rect = dot.getBoundingClientRect();
                const tooltipRect = tooltip.getBoundingClientRect();
                let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
                let top = rect.top - tooltipRect.height - 20;

                // Keep tooltip in viewport
                if (left < 10) left = 10;
                if (left + tooltipRect.width > window.innerWidth - 10) {
                    left = window.innerWidth - tooltipRect.width - 10;
                }
                if (top < 10) {
                    top = rect.bottom + 20;
                }

                tooltip.style.left = left + 'px';
                tooltip.style.top = top + 'px';
            });
        });

        // Close tooltip when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.hotspot') && !e.target.closest('.tooltip')) {
                if (activeTooltip) {
                    activeTooltip.classList.remove('active');
                    activeTooltip = null;
                }
            }
        });

        // Load 3D model
        const loader = new GLTFLoader();
        
        // Fallback: Create a simple head geometry if model is not available
        const createFallbackHead = () => {
            const geometry = new THREE.SphereGeometry(0.5, 64, 64);
            const material = new THREE.MeshStandardMaterial({
                color: 0xe8e8e8,
                roughness: 0.7,
                metalness: 0.1
            });
            model = new THREE.Mesh(geometry, material);
            currentMaterial = material;
            originalMaterial = {
                map: null,
                roughness: 0.7,
                metalness: 0.1
            };
            scene.add(model);
            document.querySelector('.loading').style.display = 'none';
        };

        // Try to load model - replace 'your-model.glb' with your actual model path
        loader.load(
            'your-model.glb', // REPLACE THIS with your model path
            (gltf) => {
                model = gltf.scene;
                
                // Center and scale model
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 1.5 / maxDim;
                
                model.scale.setScalar(scale);
                model.position.sub(center.multiplyScalar(scale));
                
                // Setup material for texture changes
                model.traverse((child) => {
                    if (child.isMesh) {
                        if (!currentMaterial) {
                            // Store reference to first material found
                            currentMaterial = child.material;
                            
                            // Clone material to avoid affecting other meshes
                            child.material = child.material.clone();
                            currentMaterial = child.material;
                            
                            originalMaterial = {
                                map: child.material.map ? child.material.map.clone() : null,
                                roughness: child.material.roughness,
                                metalness: child.material.metalness
                            };
                        }
                    }
                });
                
                scene.add(model);
                document.querySelector('.loading').style.display = 'none';
            },
            (progress) => {
                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                document.querySelector('.loading').textContent = `Lädt ${percent}%`;
            },
            (error) => {
                console.log('Model not found, using fallback geometry');
                createFallbackHead();
            }
        );

        // Update hotspot positions
        function updateHotspots() {
            if (!model) return;

            hotspots.forEach((hotspot, index) => {
                const vector = new THREE.Vector3(
                    hotspot.position.x,
                    hotspot.position.y,
                    hotspot.position.z
                );
                
                vector.applyMatrix4(model.matrixWorld);
                vector.project(camera);

                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-(vector.y) * 0.5 + 0.5) * window.innerHeight;

                const element = hotspotElements[index];
                element.style.left = x + 'px';
                element.style.top = y + 'px';

                // Hide hotspots that are behind the model
                element.style.opacity = vector.z < 1 ? '1' : '0.3';
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateHotspots();
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updateHotspots();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

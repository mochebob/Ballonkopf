<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floating Heads</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: transparent;
            overflow: hidden;
            height: 100vh;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
        }

        canvas {
            display: block;
            outline: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            color: rgba(255, 255, 255, 0.5);
            font-family: sans-serif;
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <div class="loading">LÃ¤dt...</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const scene = new THREE.Scene();
        scene.background = null;
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('scene-container').appendChild(renderer.domElement);

        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr',
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            },
            undefined,
            (error) => {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(2, 2, 3);
                scene.add(directionalLight);
            }
        );

        class FloatingHead {
            constructor(model, position) {
                this.group = new THREE.Group();
                this.model = model.clone();
                this.group.add(this.model);
                
                this.position = position.clone();
                this.position.z = 0;
                
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01, // Langsamer Start
                    (Math.random() - 0.5) * 0.01,
                    0
                );
                this.rotation = new THREE.Vector3(0, 0, Math.random() * 0.005);
                
                this.group.position.copy(this.position);
                
                this.originalVertices = [];
                this.vertexVelocities = [];
                this.mesh = null;
                
                this.model.traverse((child) => {
                    if (child.isMesh && !this.mesh) {
                        this.mesh = child;
                        this.initJelly();
                    }
                });
                
                this.radius = 0.9;
            }
            
            initJelly() {
                if (!this.mesh) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const pos = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    this.originalVertices.push(pos.clone());
                    this.vertexVelocities.push(new THREE.Vector3());
                }
            }
            
            applyForce(force, point) {
                this.velocity.add(force.multiplyScalar(0.03));
                if (!this.mesh || this.originalVertices.length === 0) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const worldVertex = this.originalVertices[i].clone().applyMatrix4(this.mesh.matrixWorld);
                    const distance = worldVertex.distanceTo(point);
                    if (distance < 0.5) {
                        const pushDir = worldVertex.clone().sub(point).normalize();
                        const strength = (1 - distance / 0.5) * 0.2;
                        const worldToLocal = new THREE.Matrix4().copy(this.mesh.matrixWorld).invert();
                        pushDir.applyMatrix4(worldToLocal);
                        pushDir.normalize();
                        this.vertexVelocities[i].add(pushDir.multiplyScalar(strength));
                    }
                }
            }
            
            updateJelly() {
                if (!this.mesh || this.originalVertices.length === 0) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    const diff = this.originalVertices[i].clone().sub(vertex);
                    this.vertexVelocities[i].add(diff.multiplyScalar(0.05));
                    this.vertexVelocities[i].multiplyScalar(0.9);
                    vertex.add(this.vertexVelocities[i]);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                positions.needsUpdate = true;
            }
            
            update(bounds, otherHeads) {
                // Anziehungskraft (reduziert)
                otherHeads.forEach(otherHead => {
                    if (otherHead === this) return;
                    const direction = otherHead.position.clone().sub(this.position);
                    const distance = direction.length();
                    if (distance > 0.1) {
                        direction.normalize();
                        const attractionForce = 0.000008; // SEHR GERING
                        this.velocity.add(direction.multiplyScalar(attractionForce));
                    }
                });
                
                // GESCHWINDIGKEITS-LIMIT
                const maxSpeed = 0.015; // Maximale Geschwindigkeit
                const currentSpeed = this.velocity.length();
                if (currentSpeed > maxSpeed) {
                    this.velocity.normalize().multiplyScalar(maxSpeed);
                }
                
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.position.z = 0;
                this.group.position.copy(this.position);
                this.group.rotation.z += this.rotation.z;
                
                // Bounds mit mehr Energy Loss
                if (Math.abs(this.position.x) > bounds.x) {
                    this.velocity.x *= -0.4; // Viel Energy Loss
                    this.position.x = Math.sign(this.position.x) * bounds.x;
                }
                if (Math.abs(this.position.y) > bounds.y) {
                    this.velocity.y *= -0.4;
                    this.position.y = Math.sign(this.position.y) * bounds.y;
                }
                
                // Kontinuierliche Abbremsung
                this.velocity.multiplyScalar(0.985);
                
                this.updateJelly();
            }
        }

        const heads = [];
        const bounds = new THREE.Vector3(4, 3, 2);

        function checkHeadCollision(head1, head2) {
            const distance = head1.position.distanceTo(head2.position);
            const minDist = head1.radius + head2.radius;
            if (distance < minDist) {
                const normal = head2.position.clone().sub(head1.position).normalize();
                const relativeVelocity = head1.velocity.clone().sub(head2.velocity);
                const speed = relativeVelocity.dot(normal);
                if (speed < 0) return;
                
                const impulse = normal.clone().multiplyScalar(speed * 0.5); // Sanfter Bounce
                
                head1.velocity.sub(impulse);
                head2.velocity.add(impulse);
                
                const collisionPoint = head1.position.clone().add(normal.clone().multiplyScalar(head1.radius));
                head1.applyForce(normal.clone().multiplyScalar(-0.2), collisionPoint);
                head2.applyForce(normal.clone().multiplyScalar(0.2), collisionPoint);
                
                const overlap = minDist - distance;
                const separation = normal.clone().multiplyScalar(overlap * 0.5);
                head1.position.sub(separation);
                head2.position.add(separation);
            }
        }

        const headLoader = new GLTFLoader();
        headLoader.load(
            'kopf.glb',
            (gltf) => {
                const headTemplate = gltf.scene;
                const box = new THREE.Box3().setFromObject(headTemplate);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 1.2 / maxDim;
                headTemplate.scale.setScalar(scale);
                const center = box.getCenter(new THREE.Vector3());
                headTemplate.position.sub(center.multiplyScalar(scale));
                
                const positions = [
                    new THREE.Vector3(-2, 1, 0),
                    new THREE.Vector3(2, -1, 0),
                    new THREE.Vector3(0, 2, 0),
                    new THREE.Vector3(-1.5, -1.5, 0),
                    new THREE.Vector3(1.5, 1.5, 0)
                ];
                
                positions.forEach(pos => {
                    const head = new FloatingHead(headTemplate, pos);
                    heads.push(head);
                    scene.add(head.group);
                });
                
                document.querySelector('.loading').style.display = 'none';
            },
            undefined,
            (error) => {
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.SphereGeometry(0.9, 64, 64);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xe8e8e8,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    const model = new THREE.Group();
                    model.add(mesh);
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 3,
                        0
                    );
                    const head = new FloatingHead(model, pos);
                    heads.push(head);
                    scene.add(head.group);
                }
                document.querySelector('.loading').style.display = 'none';
            }
        );

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            
            heads.forEach(head => {
                head.update(bounds, heads);
            });
            
            for (let i = 0; i < heads.length; i++) {
                for (let j = i + 1; j < heads.length; j++) {
                    checkHeadCollision(heads[i], heads[j]);
                }
            }
            
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>

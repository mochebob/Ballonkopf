<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moritz Sass - 3D Heads</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            background: transparent; /* Transparent für Squarespace! */
            overflow: hidden; /* Kein Scroll in iframe */
            height: 100vh;
        }

        #scene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            pointer-events: auto; /* Interaktiv */
        }

        canvas {
            display: block;
            outline: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1001;
            font-family: -apple-system, sans-serif;
        }
    </style>
</head>
<body>
    <div id="scene-container">
        <div class="loading">Lädt...</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        const scene = new THREE.Scene();
        scene.background = null; // Transparent!
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0); // Transparent
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('scene-container').appendChild(renderer.domElement);

        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr',
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            },
            undefined,
            (error) => {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(2, 2, 3);
                scene.add(directionalLight);
            }
        );

        class FloatingHead {
            constructor(model, position) {
                this.group = new THREE.Group();
                this.model = model.clone();
                this.group.add(this.model);
                
                this.position = position.clone();
                this.position.z = 0;
                
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.02,
                    (Math.random() - 0.5) * 0.02,
                    0
                );
                this.rotation = new THREE.Vector3(0, 0, Math.random() * 0.01);
                
                this.group.position.copy(this.position);
                
                this.originalVertices = [];
                this.vertexVelocities = [];
                this.mesh = null;
                
                this.model.traverse((child) => {
                    if (child.isMesh && !this.mesh) {
                        this.mesh = child;
                        this.initJelly();
                    }
                });
                
                this.radius = 0.9;
            }
            
            initJelly() {
                if (!this.mesh) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const pos = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    this.originalVertices.push(pos.clone());
                    this.vertexVelocities.push(new THREE.Vector3());
                }
            }
            
            applyForce(force, point) {
                this.velocity.add(force.multiplyScalar(0.05));
                if (!this.mesh || this.originalVertices.length === 0) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const worldVertex = this.originalVertices[i].clone().applyMatrix4(this.mesh.matrixWorld);
                    const distance = worldVertex.distanceTo(point);
                    if (distance < 0.5) {
                        const pushDir = worldVertex.clone().sub(point).normalize();
                        const strength = (1 - distance / 0.5) * 0.3;
                        const worldToLocal = new THREE.Matrix4().copy(this.mesh.matrixWorld).invert();
                        pushDir.applyMatrix4(worldToLocal);
                        pushDir.normalize();
                        this.vertexVelocities[i].add(pushDir.multiplyScalar(strength));
                    }
                }
            }
            
            updateJelly() {
                if (!this.mesh || this.originalVertices.length === 0) return;
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    const diff = this.originalVertices[i].clone().sub(vertex);
                    this.vertexVelocities[i].add(diff.multiplyScalar(0.05));
                    this.vertexVelocities[i].multiplyScalar(0.9);
                    vertex.add(this.vertexVelocities[i]);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                positions.needsUpdate = true;
            }
            
            update(bounds, otherHeads) {
                otherHeads.forEach(otherHead => {
                    if (otherHead === this) return;
                    const direction = otherHead.position.clone().sub(this.position);
                    const distance = direction.length();
                    if (distance > 0.1) {
                        direction.normalize();
                        const attractionForce = 0.0003;
                        this.velocity.add(direction.multiplyScalar(attractionForce));
                    }
                });
                
                this.position.x += this.velocity.x;
                this.position.y += this.velocity.y;
                this.position.z = 0;
                this.group.position.copy(this.position);
                this.group.rotation.z += this.rotation.z;
                
                if (Math.abs(this.position.x) > bounds.x) {
                    this.velocity.x *= -0.8;
                    this.position.x = Math.sign(this.position.x) * bounds.x;
                }
                if (Math.abs(this.position.y) > bounds.y) {
                    this.velocity.y *= -0.8;
                    this.position.y = Math.sign(this.position.y) * bounds.y;
                }
                
                this.velocity.multiplyScalar(0.995);
                this.updateJelly();
            }
        }

        let pickleModel = null;
        let pickleVelocity = new THREE.Vector3();
        const pickleSpeed = 0.2;
        const pickleDamping = 0.88;
        
        const mouse = new THREE.Vector2();
        const smoothMouse = new THREE.Vector2();
        
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        const pickleLoader = new GLTFLoader();
        pickleLoader.load(
            'gurke.glb',
            (gltf) => {
                pickleModel = gltf.scene;
                pickleModel.scale.setScalar(0.15);
                scene.add(pickleModel);
            },
            undefined,
            (error) => {
                const geometry = new THREE.SphereGeometry(0.1, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.2
                });
                pickleModel = new THREE.Mesh(geometry, material);
                scene.add(pickleModel);
            }
        );

        function updatePickle() {
            if (!pickleModel) return;
            smoothMouse.lerp(mouse, 0.15);
            const targetPos = new THREE.Vector3(smoothMouse.x * 4.0, smoothMouse.y * 3.0, 0);
            const direction = targetPos.clone().sub(pickleModel.position);
            pickleVelocity.add(direction.multiplyScalar(pickleSpeed));
            pickleVelocity.multiplyScalar(pickleDamping);
            pickleModel.position.x += pickleVelocity.x;
            pickleModel.position.y += pickleVelocity.y;
            pickleModel.position.z = 0;
            if (pickleVelocity.length() > 0.01) {
                pickleModel.rotation.z = Math.atan2(pickleVelocity.y, pickleVelocity.x);
            }
        }

        const collisionSounds = [];
        let soundsLoaded = false;
        
        function loadSounds() {
            const soundFiles = ['oh1.mp3', 'oh2.mp3', 'oh3.mp3', 'oh4.mp3'];
            soundFiles.forEach(file => {
                const audio = new Audio(file);
                audio.volume = 0.5;
                collisionSounds.push(audio);
            });
            soundsLoaded = true;
        }
        
        function playCollisionSound() {
            if (!soundsLoaded || collisionSounds.length === 0) return;
            const randomSound = collisionSounds[Math.floor(Math.random() * collisionSounds.length)];
            const sound = randomSound.cloneNode();
            sound.volume = 0.5;
            sound.play().catch(err => {});
        }
        
        loadSounds();

        const heads = [];
        const bounds = new THREE.Vector3(4, 3, 2);
        let headTemplate = null;

        function checkHeadCollision(head1, head2) {
            const distance = head1.position.distanceTo(head2.position);
            const minDist = head1.radius + head2.radius;
            if (distance < minDist) {
                const normal = head2.position.clone().sub(head1.position).normalize();
                const relativeVelocity = head1.velocity.clone().sub(head2.velocity);
                const speed = relativeVelocity.dot(normal);
                if (speed < 0) return;
                const impulse = normal.clone().multiplyScalar(speed * 1.2);
                head1.velocity.sub(impulse);
                head2.velocity.add(impulse);
                const collisionPoint = head1.position.clone().add(normal.clone().multiplyScalar(head1.radius));
                head1.applyForce(normal.clone().multiplyScalar(-0.8), collisionPoint);
                head2.applyForce(normal.clone().multiplyScalar(0.8), collisionPoint);
                const overlap = minDist - distance;
                const separation = normal.clone().multiplyScalar(overlap * 0.5);
                head1.position.sub(separation);
                head2.position.add(separation);
                playCollisionSound();
            }
        }

        function checkPickleCollision() {
            if (!pickleModel) return;
            heads.forEach(head => {
                const distance = head.position.distanceTo(pickleModel.position);
                if (distance < head.radius + 0.15) {
                    const force = pickleModel.position.clone().sub(head.position).normalize();
                    force.multiplyScalar(-1);
                    force.multiplyScalar(pickleVelocity.length() * 3.0);
                    head.applyForce(force, pickleModel.position);
                }
            });
        }

        const headLoader = new GLTFLoader();
        headLoader.load(
            'kopf.glb',
            (gltf) => {
                headTemplate = gltf.scene;
                const box = new THREE.Box3().setFromObject(headTemplate);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 1.2 / maxDim;
                headTemplate.scale.setScalar(scale);
                const center = box.getCenter(new THREE.Vector3());
                headTemplate.position.sub(center.multiplyScalar(scale));
                
                const positions = [
                    new THREE.Vector3(-2, 1, 0),
                    new THREE.Vector3(2, -1, 0),
                    new THREE.Vector3(0, 2, 0),
                    new THREE.Vector3(-1.5, -1.5, 0),
                    new THREE.Vector3(1.5, 1.5, 0)
                ];
                
                positions.forEach(pos => {
                    const head = new FloatingHead(headTemplate, pos);
                    heads.push(head);
                    scene.add(head.group);
                });
                
                document.querySelector('.loading').style.display = 'none';
            },
            undefined,
            (error) => {
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.SphereGeometry(0.9, 64, 64);
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xe8e8e8,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    const model = new THREE.Group();
                    model.add(mesh);
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 3,
                        0
                    );
                    const head = new FloatingHead(model, pos);
                    heads.push(head);
                    scene.add(head.group);
                }
                document.querySelector('.loading').style.display = 'none';
            }
        );

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            updatePickle();
            checkPickleCollision();
            heads.forEach(head => {
                head.update(bounds, heads);
            });
            for (let i = 0; i < heads.length; i++) {
                for (let j = i + 1; j < heads.length; j++) {
                    checkHeadCollision(heads[i], heads[j]);
                }
            }
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>


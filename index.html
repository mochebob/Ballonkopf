<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Moritz Sass - Portfolio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inknut+Antiqua:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none;
        }

        body {
            background: #000;
            overflow-x: hidden;
            overflow-y: auto;
        }

        .ticker-wrapper {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.8);
            overflow: hidden;
            z-index: 1000;
            display: flex;
            align-items: center;
        }

        .ticker {
            display: flex;
            white-space: nowrap;
            animation: scroll 30s linear infinite;
        }

        .ticker-item {
            font-family: 'Inknut Antiqua', serif;
            font-weight: 700;
            font-size: 100px;
            color: #00ff00;
    
            padding: 0 50px;
            letter-spacing: 0.02em;
        }

        .ticker-item a {
           
            text-decoration: none;
            border-bottom: 2px solid #00ff00;
            transition: all 0.3s;
        }

        .ticker-item a:hover {
            text-shadow: 
                0 0 20px #00ff00,
                0 0 40px #00ff00,
                0 0 60px #00ff00;
        }

        @keyframes scroll {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(-50%);
            }
        }

        .image-grid {
            position: relative;
            width: 100%;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            z-index: 1;
            margin-top: 60px;
        }

        .grid-item {
            width: 100%;
            height: 60vh;
            overflow: hidden;
            position: relative;
        }

        .grid-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
            transition: opacity 0.3s ease;
        }

        .grid-item a {
            display: block;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .grid-item a::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            transition: background 0.3s ease;
            z-index: 1;
        }

        .grid-item a:hover::before {
            background: rgba(0, 0, 0, 0);
        }

        #scene-container {
            position: fixed;
            top: 60px;
            left: 0;
            width: 100%;
            height: calc(100vh - 60px);
            z-index: 500;
            pointer-events: none;
        }

        canvas {
            display: block;
            outline: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.5);
            z-index: 1001;
            font-family: -apple-system, sans-serif;
        }

        @media (max-width: 768px) {
            .grid-item {
                height: 50vh;
            }
            .ticker-item {
                font-size: 18px;
            }
        }
    </style>
</head>
<body>
    <div class="ticker-wrapper">
        <div class="ticker">
            <div class="ticker-item">Moritz Sass Art Direction/Motion Design</div>
             <div class="ticker-item">Moritz Sass Art Direction/Motion Design</div>
             <div class="ticker-item">Moritz Sass Art Direction/Motion Design</div>
        </div>
    </div>

    <div class="image-grid">
        <div class="grid-item">
            <a href="/work/private-lounge-amg">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1707903559186-1V5YKKNESUN26FKGT0XM/Ohne+Titel_1.gif" alt="Private Lounge">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/mymcdonalds-rewards">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1633507352994-GKKL3T0S804BC8WB8G2F/db50a7e6b9bae49a.gif" alt="MyMcDonald's Rewards">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/shatten-gift">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1695629291989-087AK7S2OFYV7SHNIG2X/%23.gif" alt="Shatten">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/mcdelivery">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1623834992119-IM191VM39Q1EXLXIL3YS/A002C024_210430_R0EZ_grading_preview_2021-05-10.000310.jpg" alt="McDelivery">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/das-neue-normal">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1616698406547-PZAAXL6RZ0RNXNXAK3W4/lichtblick.png" alt="Das neue Normal">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/vertrautseltsam">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1707903931529-BCUEXASEKXT6E85BM51F/427710193_276554562123457_7195696897340489078_n.jpg" alt="Vertraut & Seltsam">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/nachtdenken">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1616698515281-YT0IT3OXWRAF89FMAF7Z/nachtdenken.png" alt="Nachtdenken">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/gestresst-und-rauschig">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1701956054735-HWZVBSWU4RYMMWC3XA0L/IMG_2360.PNG" alt="Gestresst und rauschig">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/future-is-an-attitude">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1616699778170-Q3E9J7LCH2JQIG73DE65/audi.png" alt="FutureIsAnAttitude">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/papajoes">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1616700339077-X6BQT4QWIFWYJHUYV448/papajoe.png" alt="Papa Joe's">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/imahybrid">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1616700958251-6MT4XXILA6K2SPZ44KUK/kia.png" alt="I'm a Hybrid">
            </a>
        </div>
        <div class="grid-item">
            <a href="/work/oh-opel">
                <img src="https://images.squarespace-cdn.com/content/v1/605c5c2360260c0a927ba12e/1621949720534-UA4KYUVQ4ZN3Q98PQYF2/prt_400x400_1428998783-1-1-min.jpg" alt="OH!">
            </a>
        </div>
    </div>

    <div id="scene-container">
        <div class="loading">L√§dt 3D Scene...</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

        /* ============================================
           SCENE SETUP
           ============================================ */
        const scene = new THREE.Scene();
        scene.background = null;
        
        const camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 0, 5);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            alpha: true 
        });
        renderer.setClearColor(0x000000, 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.getElementById('scene-container').appendChild(renderer.domElement);

        /* ============================================
           LIGHTING
           ============================================ */
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr',
            (texture) => {
                texture.mapping = THREE.EquirectangularReflectionMapping;
                scene.environment = texture;
            },
            undefined,
            (error) => {
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight.position.set(2, 2, 3);
                scene.add(directionalLight);
            }
        );

        /* ============================================
           FLOATING HEADS SYSTEM
           ============================================ */
        class FloatingHead {
            constructor(model, position) {
                this.group = new THREE.Group();
                this.model = model.clone();
                this.group.add(this.model);
                
                // Position & Velocity f√ºr Schwerelosigkeit
                this.position = position.clone();
                this.velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.01, // ANPASSEN: Startgeschwindigkeit
                    (Math.random() - 0.5) * 0.01,
                    (Math.random() - 0.5) * 0.005
                );
                this.rotation = new THREE.Vector3(
                    Math.random() * 0.01,
                    Math.random() * 0.01,
                    Math.random() * 0.01
                );
                
                this.group.position.copy(position);
                
                // Jelly/Gummi Physics
                this.originalVertices = [];
                this.vertexVelocities = [];
                this.mesh = null;
                
                // Finde Mesh
                this.model.traverse((child) => {
                    if (child.isMesh && !this.mesh) {
                        this.mesh = child;
                        this.initJelly();
                    }
                });
                
                // Bounding Sphere f√ºr Kollision
                this.radius = 0.9; // ANPASSEN: Kollisions-Radius (gr√∂√üer f√ºr 3x K√∂pfe)
            }
            
            initJelly() {
                if (!this.mesh) return;
                
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const pos = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    this.originalVertices.push(pos.clone());
                    this.vertexVelocities.push(new THREE.Vector3());
                }
            }
            
            applyForce(force, point) {
                // Kraft anwenden (von Gurke oder anderem Kopf)
                this.velocity.add(force.multiplyScalar(0.05)); // ANPASSEN: Kraft-Multiplikator
                
                // Gummi-Deformation
                if (!this.mesh || this.originalVertices.length === 0) return;
                
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const worldVertex = this.originalVertices[i].clone()
                        .applyMatrix4(this.mesh.matrixWorld);
                    
                    const distance = worldVertex.distanceTo(point);
                    
                    if (distance < 0.5) { // ANPASSEN: Deformations-Radius
                        const pushDir = worldVertex.clone().sub(point).normalize();
                        const strength = (1 - distance / 0.5) * 0.3; // ANPASSEN: Deformations-St√§rke
                        
                        const worldToLocal = new THREE.Matrix4()
                            .copy(this.mesh.matrixWorld).invert();
                        pushDir.applyMatrix4(worldToLocal);
                        pushDir.normalize();
                        
                        this.vertexVelocities[i].add(pushDir.multiplyScalar(strength));
                    }
                }
            }
            
            updateJelly() {
                if (!this.mesh || this.originalVertices.length === 0) return;
                
                const geometry = this.mesh.geometry;
                const positions = geometry.attributes.position;
                
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3(
                        positions.getX(i),
                        positions.getY(i),
                        positions.getZ(i)
                    );
                    
                    // Spring zur√ºck
                    const diff = this.originalVertices[i].clone().sub(vertex);
                    this.vertexVelocities[i].add(diff.multiplyScalar(0.05)); // ANPASSEN: Springback
                    
                    // Damping
                    this.vertexVelocities[i].multiplyScalar(0.9); // ANPASSEN: D√§mpfung
                    
                    // Update
                    vertex.add(this.vertexVelocities[i]);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
                
                positions.needsUpdate = true;
            }
            
            update(bounds) {
                // Schwerelosigkeit: Position updaten
                this.position.add(this.velocity);
                this.group.position.copy(this.position);
                
                // Sanfte Rotation
                this.group.rotation.x += this.rotation.x;
                this.group.rotation.y += this.rotation.y;
                this.group.rotation.z += this.rotation.z;
                
                // Bounds checking (Bounce an W√§nden)
                if (Math.abs(this.position.x) > bounds.x) {
                    this.velocity.x *= -0.8;
                    this.position.x = Math.sign(this.position.x) * bounds.x;
                }
                if (Math.abs(this.position.y) > bounds.y) {
                    this.velocity.y *= -0.8;
                    this.position.y = Math.sign(this.position.y) * bounds.y;
                }
                if (Math.abs(this.position.z) > bounds.z) {
                    this.velocity.z *= -0.8;
                    this.position.z = Math.sign(this.position.z) * bounds.z;
                }
                
                // Velocity Damping (langsam abbremsen)
                this.velocity.multiplyScalar(0.995); // ANPASSEN: Wie schnell abbremst
                
                // Jelly Update
                this.updateJelly();
            }
        }

        /* ============================================
           PICKLE (GURKE)
           ============================================ */
        let pickleModel = null;
        let pickleVelocity = new THREE.Vector3();
        const pickleSpeed = 0.2;
        const pickleDamping = 0.88;
        
        const mouse = new THREE.Vector2();
        const smoothMouse = new THREE.Vector2();
        
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });

        const pickleLoader = new GLTFLoader();
        pickleLoader.load(
            'gurke.glb',
            (gltf) => {
                pickleModel = gltf.scene;
                pickleModel.scale.setScalar(0.15); // ANPASSEN: Gurken-Gr√∂√üe (gr√∂√üer f√ºr gr√∂√üere K√∂pfe)
                scene.add(pickleModel);
            },
            undefined,
            (error) => {
                // Fallback
                const geometry = new THREE.SphereGeometry(0.1, 16, 16); // Gr√∂√üer
                const material = new THREE.MeshStandardMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.2
                });
                pickleModel = new THREE.Mesh(geometry, material);
                scene.add(pickleModel);
            }
        );

        function updatePickle() {
            if (!pickleModel) return;

            smoothMouse.lerp(mouse, 0.15);

            const depthVariation = smoothMouse.x * 0.5;
            const targetPos = new THREE.Vector3(
                smoothMouse.x * 4.0, // ANPASSEN: Bewegungsbereich
                smoothMouse.y * 3.0,
                2.0 + depthVariation
            );

            const direction = targetPos.clone().sub(pickleModel.position);
            pickleVelocity.add(direction.multiplyScalar(pickleSpeed));
            pickleVelocity.multiplyScalar(pickleDamping);
            pickleModel.position.add(pickleVelocity);

            if (pickleVelocity.length() > 0.01) {
                pickleModel.rotation.z = Math.atan2(pickleVelocity.y, pickleVelocity.x);
                pickleModel.rotation.y += 0.03;
            }
        }

        /* ============================================
           HEADS ARRAY & COLLISION
           ============================================ */
        const heads = [];
        const bounds = new THREE.Vector3(4, 3, 2); // ANPASSEN: Raum-Grenzen
        let headTemplate = null;

        // Kollision zwischen zwei K√∂pfen
        function checkHeadCollision(head1, head2) {
            const distance = head1.position.distanceTo(head2.position);
            const minDist = head1.radius + head2.radius;
            
            if (distance < minDist) {
                // Kollision! Beide abprallen
                const normal = head2.position.clone().sub(head1.position).normalize();
                const relativeVelocity = head1.velocity.clone().sub(head2.velocity);
                const speed = relativeVelocity.dot(normal);
                
                if (speed < 0) return; // Already separating
                
                const impulse = normal.clone().multiplyScalar(speed * 1.2); // ANPASSEN: Bounce-St√§rke (erh√∂ht von 0.8)
                
                head1.velocity.sub(impulse);
                head2.velocity.add(impulse);
                
                // Gummi-Deformation an Kollisionspunkt
                const collisionPoint = head1.position.clone().add(normal.clone().multiplyScalar(head1.radius));
                head1.applyForce(normal.clone().multiplyScalar(-0.8), collisionPoint); // St√§rker
                head2.applyForce(normal.clone().multiplyScalar(0.8), collisionPoint);
                
                // Separate overlapping heads
                const overlap = minDist - distance;
                const separation = normal.clone().multiplyScalar(overlap * 0.5);
                head1.position.sub(separation);
                head2.position.add(separation);
                
                console.log('üí• Kopf-Kollision!'); // Debug
            }
        }

        // Kollision mit Gurke
        function checkPickleCollision() {
            if (!pickleModel) return;
            
            heads.forEach(head => {
                const distance = head.position.distanceTo(pickleModel.position);
                
                if (distance < head.radius + 0.15) { // ANPASSEN: Gurken-Radius (0.15 f√ºr gr√∂√üere Gurke)
                    const force = pickleModel.position.clone().sub(head.position).normalize();
                    force.multiplyScalar(-1); // Invertiert: Kopf fliegt WEG von Gurke
                    force.multiplyScalar(pickleVelocity.length() * 3.0); // ANPASSEN: Sto√ü-Kraft (erh√∂ht)
                    
                    head.applyForce(force, pickleModel.position);
                    
                    console.log('üí• Gurke trifft Kopf!'); // Debug
                }
            });
        }

        /* ============================================
           LOAD HEAD MODEL
           ============================================ */
        const headLoader = new GLTFLoader();
        headLoader.load(
            'kopf.glb',
            (gltf) => {
                headTemplate = gltf.scene;
                
                // Skaliere Template
                const box = new THREE.Box3().setFromObject(headTemplate);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 1.2 / maxDim; // ANPASSEN: Kopf-Gr√∂√üe (1.2 = 3x gr√∂√üer als vorher)
                
                headTemplate.scale.setScalar(scale);
                
                // Center
                const center = box.getCenter(new THREE.Vector3());
                headTemplate.position.sub(center.multiplyScalar(scale));
                
                // Erstelle 5 K√∂pfe an verschiedenen Positionen
                const positions = [
                    new THREE.Vector3(-2, 1, 0),
                    new THREE.Vector3(2, -1, -0.5),
                    new THREE.Vector3(0, 2, 0.5),
                    new THREE.Vector3(-1.5, -1.5, -0.3),
                    new THREE.Vector3(1.5, 1.5, 0.3)
                ];
                
                positions.forEach(pos => {
                    const head = new FloatingHead(headTemplate, pos);
                    heads.push(head);
                    scene.add(head.group);
                });
                
                document.querySelector('.loading').style.display = 'none';
                console.log('‚úÖ 5 K√∂pfe erstellt!');
            },
            undefined,
            (error) => {
                console.log('Fallback Spheres');
                // Fallback: 5 Kugeln
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.SphereGeometry(0.9, 64, 64); // 3x gr√∂√üer
                    const material = new THREE.MeshStandardMaterial({
                        color: 0xe8e8e8,
                        roughness: 0.5,
                        metalness: 0.3
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    const model = new THREE.Group();
                    model.add(mesh);
                    
                    const pos = new THREE.Vector3(
                        (Math.random() - 0.5) * 4,
                        (Math.random() - 0.5) * 3,
                        (Math.random() - 0.5) * 2
                    );
                    
                    const head = new FloatingHead(model, pos);
                    heads.push(head);
                    scene.add(head.group);
                }
                document.querySelector('.loading').style.display = 'none';
            }
        );

        /* ============================================
           RESIZE & ANIMATION
           ============================================ */
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            
            updatePickle();
            checkPickleCollision();
            
            // Update alle K√∂pfe
            heads.forEach(head => {
                head.update(bounds);
            });
            
            // Kopf-zu-Kopf Kollision
            for (let i = 0; i < heads.length; i++) {
                for (let j = i + 1; j < heads.length; j++) {
                    checkHeadCollision(heads[i], heads[j]);
                }
            }
            
            renderer.render(scene, camera);
        }

        animate();
        
        console.log('üöÄ Schwerelosigkeits-System aktiv!');
    </script>
</body>
</html>
